/* automatically generated by rust-bindgen 0.71.1 */

pub const __MINGW64_VERSION_MAJOR: u32 = 13;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &[u8; 6] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_GCC_VERSION: u32 = 0;
pub const __MINGW_SEC_WARN_STR : & [u8 ; 92] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const USE___UUIDOF: u32 = 1;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1537;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type rsize_t = usize;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of localeinfo_struct"][::std::mem::size_of::<localeinfo_struct>() - 16usize];
    ["Alignment of localeinfo_struct"][::std::mem::align_of::<localeinfo_struct>() - 8usize];
    ["Offset of field: localeinfo_struct::locinfo"]
        [::std::mem::offset_of!(localeinfo_struct, locinfo) - 0usize];
    ["Offset of field: localeinfo_struct::mbcinfo"]
        [::std::mem::offset_of!(localeinfo_struct, mbcinfo) - 8usize];
};
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tagLC_ID"][::std::mem::size_of::<tagLC_ID>() - 6usize];
    ["Alignment of tagLC_ID"][::std::mem::align_of::<tagLC_ID>() - 2usize];
    ["Offset of field: tagLC_ID::wLanguage"][::std::mem::offset_of!(tagLC_ID, wLanguage) - 0usize];
    ["Offset of field: tagLC_ID::wCountry"][::std::mem::offset_of!(tagLC_ID, wCountry) - 2usize];
    ["Offset of field: tagLC_ID::wCodePage"][::std::mem::offset_of!(tagLC_ID, wCodePage) - 4usize];
};
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut wchar_t,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of threadlocaleinfostruct__bindgen_ty_1"]
        [::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>() - 32usize];
    ["Alignment of threadlocaleinfostruct__bindgen_ty_1"]
        [::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>() - 8usize];
    ["Offset of field: threadlocaleinfostruct__bindgen_ty_1::locale"]
        [::std::mem::offset_of!(threadlocaleinfostruct__bindgen_ty_1, locale) - 0usize];
    ["Offset of field: threadlocaleinfostruct__bindgen_ty_1::wlocale"]
        [::std::mem::offset_of!(threadlocaleinfostruct__bindgen_ty_1, wlocale) - 8usize];
    ["Offset of field: threadlocaleinfostruct__bindgen_ty_1::refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct__bindgen_ty_1, refcount) - 16usize];
    ["Offset of field: threadlocaleinfostruct__bindgen_ty_1::wrefcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct__bindgen_ty_1, wrefcount) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of threadlocaleinfostruct"][::std::mem::size_of::<threadlocaleinfostruct>() - 352usize];
    ["Alignment of threadlocaleinfostruct"]
        [::std::mem::align_of::<threadlocaleinfostruct>() - 8usize];
    ["Offset of field: threadlocaleinfostruct::refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct, refcount) - 0usize];
    ["Offset of field: threadlocaleinfostruct::lc_codepage"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_codepage) - 4usize];
    ["Offset of field: threadlocaleinfostruct::lc_collate_cp"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_collate_cp) - 8usize];
    ["Offset of field: threadlocaleinfostruct::lc_handle"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_handle) - 12usize];
    ["Offset of field: threadlocaleinfostruct::lc_id"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_id) - 36usize];
    ["Offset of field: threadlocaleinfostruct::lc_category"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_category) - 72usize];
    ["Offset of field: threadlocaleinfostruct::lc_clike"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_clike) - 264usize];
    ["Offset of field: threadlocaleinfostruct::mb_cur_max"]
        [::std::mem::offset_of!(threadlocaleinfostruct, mb_cur_max) - 268usize];
    ["Offset of field: threadlocaleinfostruct::lconv_intl_refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lconv_intl_refcount) - 272usize];
    ["Offset of field: threadlocaleinfostruct::lconv_num_refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lconv_num_refcount) - 280usize];
    ["Offset of field: threadlocaleinfostruct::lconv_mon_refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lconv_mon_refcount) - 288usize];
    ["Offset of field: threadlocaleinfostruct::lconv"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lconv) - 296usize];
    ["Offset of field: threadlocaleinfostruct::ctype1_refcount"]
        [::std::mem::offset_of!(threadlocaleinfostruct, ctype1_refcount) - 304usize];
    ["Offset of field: threadlocaleinfostruct::ctype1"]
        [::std::mem::offset_of!(threadlocaleinfostruct, ctype1) - 312usize];
    ["Offset of field: threadlocaleinfostruct::pctype"]
        [::std::mem::offset_of!(threadlocaleinfostruct, pctype) - 320usize];
    ["Offset of field: threadlocaleinfostruct::pclmap"]
        [::std::mem::offset_of!(threadlocaleinfostruct, pclmap) - 328usize];
    ["Offset of field: threadlocaleinfostruct::pcumap"]
        [::std::mem::offset_of!(threadlocaleinfostruct, pcumap) - 336usize];
    ["Offset of field: threadlocaleinfostruct::lc_time_curr"]
        [::std::mem::offset_of!(threadlocaleinfostruct, lc_time_curr) - 344usize];
};
pub type threadlocinfo = threadlocaleinfostruct;
unsafe extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __max_align_ld: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 16usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 8usize];
    ["Offset of field: max_align_t::__max_align_ll"]
        [::std::mem::offset_of!(max_align_t, __max_align_ll) - 0usize];
    ["Offset of field: max_align_t::__max_align_ld"]
        [::std::mem::offset_of!(max_align_t, __max_align_ld) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EasyJSRHandle {
    _unused: [u8; 0],
}
pub const JSArgType_JSARG_TYPE_INT: JSArgType = 0;
pub const JSArgType_JSARG_TYPE_DOUBLE: JSArgType = 1;
pub const JSArgType_JSARG_TYPE_STRING: JSArgType = 2;
pub const JSArgType_JSARG_TYPE_FLOAT: JSArgType = 3;
pub const JSArgType_JSARG_TYPE_BOOL: JSArgType = 4;
pub const JSArgType_JSARG_TYPE_INT64_T: JSArgType = 5;
pub const JSArgType_JSARG_TYPE_UINT32_T: JSArgType = 6;
pub const JSArgType_JSARG_TYPE_C_ARRAY: JSArgType = 7;
pub const JSArgType_JSARG_TYPE_NULL: JSArgType = 8;
pub const JSArgType_JSARG_TYPE_UNDEFINED: JSArgType = 9;
pub const JSArgType_JSARG_TYPE_UINT8_ARRAY: JSArgType = 10;
pub const JSArgType_JSARG_TYPE_INT32_ARRAY: JSArgType = 11;
pub const JSArgType_JSARG_TYPE_UINT32_ARRAY: JSArgType = 12;
pub const JSArgType_JSARG_TYPE_INT64_ARRAY: JSArgType = 13;
pub const JSArgType_JSARG_TYPE_INT8_ARRAY: JSArgType = 14;
pub const JSArgType_JSARG_TYPE_UINT16_ARRAY: JSArgType = 15;
pub const JSArgType_JSARG_TYPE_INT16_ARRAY: JSArgType = 16;
pub const JSArgType_JSARG_TYPE_UINT64_ARRAY: JSArgType = 17;
pub const JSArgType_JSARG_TYPE_FLOAT_ARRAY: JSArgType = 18;
pub const JSArgType_JSARG_TYPE_EXCEPTION: JSArgType = 19;
#[doc = " @brief C version of our JSArg union"]
pub type JSArgType = ::std::os::raw::c_int;
#[doc = " @brief C version of our JSArg union"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JSArg {
    pub type_: JSArgType,
    pub value: JSArg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JSArg__bindgen_ty_1 {
    pub int_val: ::std::os::raw::c_int,
    pub double_val: f64,
    pub str_val: *const ::std::os::raw::c_char,
    pub jsvalue_id: ::std::os::raw::c_int,
    pub float_val: f32,
    pub bool_val: bool,
    pub uint32_t_val: u32,
    pub int64_t_val: i64,
    pub c_array_val: JSArg__bindgen_ty_1__bindgen_ty_1,
    pub u8_array_val: JSArg__bindgen_ty_1__bindgen_ty_2,
    pub i32_array_val: JSArg__bindgen_ty_1__bindgen_ty_3,
    pub u32_array_val: JSArg__bindgen_ty_1__bindgen_ty_4,
    pub i64_array_val: JSArg__bindgen_ty_1__bindgen_ty_5,
    pub i8_array_val: JSArg__bindgen_ty_1__bindgen_ty_6,
    pub i16_array_val: JSArg__bindgen_ty_1__bindgen_ty_7,
    pub u16_array_val: JSArg__bindgen_ty_1__bindgen_ty_8,
    pub u64_array_val: JSArg__bindgen_ty_1__bindgen_ty_9,
    pub float_array_val: JSArg__bindgen_ty_1__bindgen_ty_10,
    pub exception_val: JSArg__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_1 {
    pub items: *mut *mut JSArg,
    pub count: usize,
    pub capacity: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_1>() - 24usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_1::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_1, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_1::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_1, count) - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_1::capacity"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_1, capacity) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_2 {
    pub items: *const u8,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_2::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_2, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_2::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_2, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_3 {
    pub items: *const i32,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_3::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_3, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_3::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_3, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_4 {
    pub items: *const u32,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_4>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_4::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_4, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_4::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_4, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_5 {
    pub items: *const i64,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_5>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_5::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_5, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_5::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_5, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_6 {
    pub items: *const i8,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_6::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_6, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_6::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_6, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_7 {
    pub items: *const i16,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_7::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_7, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_7::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_7, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_8 {
    pub items: *const u16,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_8"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_8>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_8"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_8>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_8::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_8, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_8::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_8, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_9 {
    pub items: *const u64,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_9"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_9>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_9"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_9>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_9::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_9, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_9::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_9, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_10 {
    pub items: *const f32,
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_10"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_10>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_10"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_10>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_10::items"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_10, items) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_10::count"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_10, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSArg__bindgen_ty_1__bindgen_ty_11 {
    pub msg: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1__bindgen_ty_11"]
        [::std::mem::size_of::<JSArg__bindgen_ty_1__bindgen_ty_11>() - 16usize];
    ["Alignment of JSArg__bindgen_ty_1__bindgen_ty_11"]
        [::std::mem::align_of::<JSArg__bindgen_ty_1__bindgen_ty_11>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_11::msg"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_11, msg) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1__bindgen_ty_11::name"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1__bindgen_ty_11, name) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg__bindgen_ty_1"][::std::mem::size_of::<JSArg__bindgen_ty_1>() - 24usize];
    ["Alignment of JSArg__bindgen_ty_1"][::std::mem::align_of::<JSArg__bindgen_ty_1>() - 8usize];
    ["Offset of field: JSArg__bindgen_ty_1::int_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, int_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::double_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, double_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::str_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, str_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::jsvalue_id"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, jsvalue_id) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::float_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, float_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::bool_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, bool_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::uint32_t_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, uint32_t_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::int64_t_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, int64_t_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::c_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, c_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::u8_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, u8_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::i32_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, i32_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::u32_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, u32_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::i64_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, i64_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::i8_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, i8_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::i16_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, i16_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::u16_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, u16_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::u64_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, u64_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::float_array_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, float_array_val) - 0usize];
    ["Offset of field: JSArg__bindgen_ty_1::exception_val"]
        [::std::mem::offset_of!(JSArg__bindgen_ty_1, exception_val) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSArg"][::std::mem::size_of::<JSArg>() - 32usize];
    ["Alignment of JSArg"][::std::mem::align_of::<JSArg>() - 8usize];
    ["Offset of field: JSArg::type_"][::std::mem::offset_of!(JSArg, type_) - 0usize];
    ["Offset of field: JSArg::value"][::std::mem::offset_of!(JSArg, value) - 8usize];
};
#[doc = " @brief C Callback wrapper for DynCallback"]
pub type C_Callback = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut *mut JSArg,
        arg_count: usize,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut JSArg,
>;
#[doc = " @brief C wrapper for FileLoaderFn"]
pub type C_FileLoaderFn = ::std::option::Option<
    unsafe extern "C" fn(
        file_path: *const ::std::os::raw::c_char,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
#[doc = " @brief C version of JSMethod"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSMethod {
    pub name: *const ::std::os::raw::c_char,
    pub cb: C_Callback,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of JSMethod"][::std::mem::size_of::<JSMethod>() - 24usize];
    ["Alignment of JSMethod"][::std::mem::align_of::<JSMethod>() - 8usize];
    ["Offset of field: JSMethod::name"][::std::mem::offset_of!(JSMethod, name) - 0usize];
    ["Offset of field: JSMethod::cb"][::std::mem::offset_of!(JSMethod, cb) - 8usize];
    ["Offset of field: JSMethod::opaque"][::std::mem::offset_of!(JSMethod, opaque) - 16usize];
};
unsafe extern "C" {
    #[doc = " @brief Create a new easyjs runtime.\n\n It will have it's own callables, modules, classes, etc. It is all sandboxed within itself."]
    pub fn ejr_new() -> *mut EasyJSRHandle;
}
unsafe extern "C" {
    #[doc = " @brief Create a int JSArg.\n\n @param value The int\n\n @return JSArg"]
    pub fn jsarg_int(value: ::std::os::raw::c_int) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a const char* JSArg.\n\n This copies the value so feel free to delete afterwards.\n\n @param value The const char*\n\n @return JSArg"]
    pub fn jsarg_str(value: *const ::std::os::raw::c_char) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a double JSArg.\n\n @param value The double\n\n @return JSArg"]
    pub fn jsarg_double(value: f64) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a float JSArg.\n\n @param value The float\n\n @return JSArg"]
    pub fn jsarg_float(value: f32) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a int64_t JSArg.\n\n @param value The int64_t\n\n @return JSArg"]
    pub fn jsarg_int64t(value: i64) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a uint32_t JSArg.\n\n @param value The uint32_t\n\n @return JSArg"]
    pub fn jsarg_uint32t(value: u32) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a C-Array JSArg.\n\n @param count The size of the array\n\n @return JSArg"]
    pub fn jsarg_carray(count: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a null JSArg.\n\n @return JSArg"]
    pub fn jsarg_null() -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a bool JSArg.\n\n @param value The bool\n\n @return JSArg"]
    pub fn jsarg_bool(value: bool) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<uint8_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The uint8_t*\n @param argc The number of uint8_ts.\n\n @return JSArg"]
    pub fn jsarg_u8_array(args: *const u8, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<int32_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The int32_t*\n @param argc The number of int32_t.\n\n @return JSArg"]
    pub fn jsarg_i32_array(args: *const i32, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<uint32_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The uint32_t*\n @param argc The number of uint32_t.\n\n @return JSArg"]
    pub fn jsarg_u32_array(args: *const u32, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<int64_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The int64_t*\n @param argc The number of int64_t.\n\n @return JSArg"]
    pub fn jsarg_i64_array(args: *const i64, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<int8_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The int8_t*\n @param argc The number of int8_t.\n\n @return JSArg"]
    pub fn jsarg_i8_array(args: *const i8, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<int16_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The int16_t*\n @param argc The number of int16_t.\n\n @return JSArg"]
    pub fn jsarg_i16_array(args: *const i16, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<uint16_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The uint16_t*\n @param argc The number of uint16_t.\n\n @return JSArg"]
    pub fn jsarg_u16_array(args: *const u16, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<uint64_t>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The uint64_t*\n @param argc The number of uint64_t.\n\n @return JSArg"]
    pub fn jsarg_u64_array(args: *const u64, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgTypedArray<float>.\n\n This will copy the memory so feel very free to free it.\n\n @param args The float*\n @param argc The number of float.\n\n @return JSArg"]
    pub fn jsarg_float_array(args: *const f32, argc: usize) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArgException.\n\n This will copy the memory so feel free to delete after this.\n\n @param message The exceptions message\n @param name The exceptions name\n\n @return JSArg"]
    pub fn jsarg_exception(
        message: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Add a JSArg value to a array.\n\n @param arg Pointer to the array.\n @param value the JSArg value."]
    pub fn jsarg_add_value_to_c_array(arg: *mut JSArg, value: *mut JSArg);
}
unsafe extern "C" {
    #[doc = " @brief Get a JSArg from a JSValue(int)\n\n @param handle the Easyjs runtime\n @param value the JSValue(int)\n\n @return JSArg"]
    pub fn jsarg_from_jsvalue(
        handle: *mut EasyJSRHandle,
        value: ::std::os::raw::c_int,
    ) -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Create a undefined JSArg.\n\n @return JSArg"]
    pub fn jsarg_undefined() -> *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Free a easyjs runtime"]
    pub fn ejr_free(handle: *mut EasyJSRHandle);
}
unsafe extern "C" {
    #[doc = " @brief Free a JSArg.\n\n @param arg A pointer to the JSArg to free."]
    pub fn jsarg_free(arg: *mut JSArg);
}
unsafe extern "C" {
    #[doc = " @brief Free A JSArg**\n\n @param args A pointer of pointers of JSArgs\n @param argc Number of pointers."]
    pub fn jsarg_free_all(args: *mut *mut JSArg, argc: usize);
}
unsafe extern "C" {
    #[doc = " @brief Create a JSArg**\n\n @param argc Count of args this can hold\n\n @return a Pointer of Pointers"]
    pub fn jsarg_make_list(argc: usize) -> *mut *mut JSArg;
}
unsafe extern "C" {
    #[doc = " @brief Add a JSArg to a JSArg**\n\n This is NOT for a C_Array! But rather a list of JSArgs\n\n @param jsarg the list ptr\n @param njsarg the jsarg to add\n @param i the index where this goes"]
    pub fn jsarg_add_to_list(jsarg: *mut *mut JSArg, njsarg: *mut JSArg, i: usize);
}
unsafe extern "C" {
    #[doc = " @brief Set the file_loader function.\n\n @param handle the easyjsr runtime.\n @param fn The file loader function.\n @param opaque some opaque data.\n"]
    pub fn ejr_set_file_loader(
        handle: *mut EasyJSRHandle,
        fn_: C_FileLoaderFn,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Evaluate a JS script at the global level.\n\n @param handle the easyjsr runtime.\n @param js The JS code.\n @param file_name The name of the file.\n\n @return The id of the created JSValue."]
    pub fn ejr_eval_script(
        handle: *mut EasyJSRHandle,
        js: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Evaluate a JS script as a module level.\n\n @param handle the easyjsr runtime.\n @param js The JS code.\n @param file_name The name of the file.\n\n @return The id of the created JSValue."]
    pub fn ejr_eval_module(
        handle: *mut EasyJSRHandle,
        js: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Evaluate a JS function in the current scope/runtime.\n\n IMPORTANT: args are freed during this call. If you plan to use them again, copy them.\n\n @param handle the easyjsr runtime.\n @param fn_name The JS function name.\n @param args The args to pass into the function.\n @param arg_count Number of args being passed.\n\n @return The id of the resulted JSValue."]
    pub fn ejr_eval_function(
        handle: *mut EasyJSRHandle,
        fn_name: *const ::std::os::raw::c_char,
        args: *mut *mut JSArg,
        arg_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Convert a JSValue into a c_string.\n\n @param handle the easyjsr runtime.\n @param value_id The id of the JSValue to be converted.\n\n @return The c_string."]
    pub fn ejr_val_to_string(
        handle: *mut EasyJSRHandle,
        value_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Evaluate a JS function in the current scope/runtime on a class or object.\n\n IMPORTANT: args are freed during this call. If you plan to use them again, copy them.\n\n @param handle the easyjsr runtime.\n @param value_id The objects/classes id in jsvad\n @param fn_name The JS function name.\n @param args The args to pass into the function.\n @param arg_count Number of args being passed.\n\n @return The id of the resulted JSValue."]
    pub fn ejr_eval_class_function(
        handle: *mut EasyJSRHandle,
        value_id: ::std::os::raw::c_int,
        fn_name: *const ::std::os::raw::c_char,
        args: *mut *mut JSArg,
        arg_count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a property from a object.\n\n @param handle the easyjsr runtime.\n @param value_id The objects/classes id in jsvad\n @param property The property name.\n\n @return the Id of the resulted value."]
    pub fn ejr_get_property_from(
        handle: *mut EasyJSRHandle,
        value_id: ::std::os::raw::c_int,
        property: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a property from Global scope.\n\n @param handle the easyjsr runtime.\n @param property The property name.\n\n @return the Id of the resulted value."]
    pub fn ejr_get_from_global(
        handle: *mut EasyJSRHandle,
        property: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Register a callback in JS.\n\n @param handle The easyjsr runtime.\n @param fn_name Name to give the callback.\n @param cb The actual C callback.\n @param opaque Opaque user data."]
    pub fn ejr_register_callback(
        handle: *mut EasyJSRHandle,
        fn_name: *const ::std::os::raw::c_char,
        cb: C_Callback,
        opaque: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Register a module in JS.\n\n @param handle The easyjsr runtime.\n @param module_name Name to give the module.\n @param methods A array of methods to add to the runtime.\n @param method_count number of methods."]
    pub fn ejr_register_module(
        handle: *mut EasyJSRHandle,
        module_name: *const ::std::os::raw::c_char,
        methods: *mut JSMethod,
        method_count: usize,
    );
}
unsafe extern "C" {
    #[doc = " @brief Free a C string.\n\n @param c_string The c string to free."]
    pub fn ejr_free_string(c_string: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Free a JSValue within the JSValueAD.\n\n @param handle The easyjsr runtime associated.\n @param value_id id of the value to free."]
    pub fn ejr_free_jsvalue(handle: *mut EasyJSRHandle, value_id: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
